# Cryptocurrency Exchange

This document outlines information about project architecture, third party APIs and technology to be used. Since we are in the discovery phase, this is currently a listing of available options, suggestions, information to help us reach decisions about what to use... once development commences it will be filtered down to highlight the technology that is actually in use and how it is being used. This will also hold the high-level documentation for the project.

##  A Preface on APIs

Some APIs are webservices that you send or retrieve data from, usually in the [JSON](https://en.wikipedia.org/wiki/JSON) format, although some may use [XML](https://en.wikipedia.org/wiki/XML). Webservices expose a URL and they have a set contract, the data you send and recieve will be in a defined format, including parameters you can include in the URL itself (webservices that provide URL parameters and use the JSON data format are known as [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) services). Because these URL based requests use plain text data formats, using them is programming language agnostic, you can call them from any application, whether it is running on a server (Node.js, Java , Ruby, Python or Microsoft ASP.NET using Visual Basic or C#) a native desktop or mobile app (Windows .NET applications, iPhone - Objective C, Android - Java Android SDK -- or an interpreted language that cross compiles so the same app can to run on any or all of these, such as the Javascript framework React Native) or even in a web application running entirely on the client side in Javascript (i.e. everything happens in the web browser and it doesn't need to make any calls to *our servers* which is a win in terms of security if we don't need to store any files, data or secure any server side code).

Some APIs work directly with files and that would require the code to run on our server. Some provide abstractions (also known as facades) that make it simpler, you may only need to provide a small set of necessary data and execute a single action vs making many different calls and having to execute more individual steps. Some APIs might also provide abstractions that allow you to do similar things (Bitcoin, Litecoin and Ethereum transactions are all ) in the exact same way, where the code to do each of these things individually in the lower level APIs is potentially vastly different. These types of APIs are provided as code that you need to include in your project, making where you are able to execute this code and the programming language you are using matter, they may provide versions of the API in multiple languages, but you must pick one of the ones they support. That being said, depending on the architecture of the application you can have multiple different modular parts to the application, where each can be written in a different language if needed. If we, for example, needed to write a part of the application to perform transactions for a specific currency using Java, we could write that code as a handful of micro services that expose REST APIs which we could then call from the rest of our application. All this being said, almost every API we potentially will need to use will likely provide a module for Node.js, which is what I prefer we write the majority of our server-side code for. All of our client-side code will be Javascript and using Node.js all of the server side code would be as well.

## Technology and Architecture

Here are my suggestions:

* We will have linux VPS or cloud servers to run our services on. If we are using VPS servers, we should host a copy of our production environment with two separate service providers, with a load balancer separating traffic between them, so that if one of our providers whole network goes down, we can route all of our traffic over to the other until the issue is resolved and that way keep our system online with little interruption to our customers.
* All source code will be stored here on Github, with this project serving as the main repo and linking out to any required sub-projects we may need to create.
* All source code to be written in [TypeScript](https://www.typescriptlang.org/) an extension to the Javascript language that adds many useful features from other programming languages that Javascript doesn't directly support -- the code is interpreted and compiled into Javascript that can then be run anywhere. The language adds type declaration to Javascript which prevents numerous runtime errors and the compilation process allows you to find and eliminate a number of bugs in the code long before it ever executes.
* All code that must be written in some other language, per the requirements of a necessary API (Java, etc), should be packaged as self-contained microservices that provide REST endpdoints. These projects should contain all the code, configuration, scripts and documentation necessary to stand the service up, such that we can log in to a server where we want it to run, perform a Git checkout of a single project, execute a build script in the main project directory and then execute the command to start the service. The instructions for building and starting the service should be contained in the README.md for the project.
* Each distinct set of APIs we write should be deployed as Node.js microservices. The smaller and more self-contained these are better, such that, let's say we make some changes to the way we handle litecoin, we could deploy only the new litecoin services out to production without touching the rest of the system that we know is working.
* The website for the project should be developed using the [React](https://reactjs.org/) framework and jQuery should also be available there. We should use Bootstrap to build a responsive layout. We should use Less to extend our stylesheets and generate CSS. We should use D3 to build graphs, charts and other visualizations. The UI should have a Grunt build and should use Bower for dependency management. There are a handful of libraries I have developed in my own personal Github that will be useful for the UI.
* Native mobile applications should be developed in React native.
* A library of shared code that may be used across the UI, services and mobile apps should be provided with its own Git repository. This library should expose a number of node.js compliant modules that the services can require directly and Browserify should be used to create a library that can be imported into the UI. All third party npm modules that don't have a browser-friendly version available through Bower should be included in this Browserify bundle.
* We should have robust logging of everything that happens, especially errors. We should have tools in place to analyze the traffic and errors that are occurring so that we can build important systems: notifications to alert us if many errors start occurring so that we can respond to the situation and stabilize the system, dashboards to show us green/yellow/red lights indicating the status of the interlocking pieces of the system, analysis of the activity going on, graphs and other data visualization of what people are doing with the system, how it is performing, trends and the values of the currencies, our accounts, etc.
* We need to stand up a development and QA environments where we can deploy the latest code and test it before deciding to deploy it out to production.
* We should do TDD (test driven development), writing our code modules againt unit tests. We should also write a suite of Selenium tests for the UI.
* 
* We should implement static code analysis to look for potential bugs, common mistakes and to format the code to enforce common conventions. We should document all the code with code comments. We should minify and obfuscate the UI code to improve performance and   conceal how the code works. Any proprietary algorithms, keys and other data that we want to protect from theft should be accessed in the server-side code. Anything in the client side that exposes how the server
* We should stand up a TeamCity/Jenkins continuous integration server. It should have jobs to manually build and deploy all modules to the various servers. When code is checked in it should build and execute unit tests, with failures notifying the person that checked it in. Success should trigger builds of any downstream projects (in the case of shared code) and then a deployment to the development environment. All deployment builds should trigger a set of Selenium based smoke tests to verify that the component deployed succesfully, is online and is working correctly. Each environment should have a full build job that executes automated tests to verify it end-to-end. QA should have an automatic nightly build that first executes a check to see if any new code has been checked in that day and if so a full deployment should be triggered and then verified. Screenshots should be implemented in the automated tests so that we can also visually verify that everything looked okay when the tests were executed.
* Production deployments should be rolled out using the hot/cold production server method: In a VPS based architecture, we use the load balancer to direct all traffic to one production instance, verifying that the other is now cold and then deploy the new code to the cold instance. Otherwise, in a cloud based architecture we run an automated script that provisions a brand new virtual server and deploys everything to it. After the deployment and automated tests are complete, we use a special means to manually target the cold production server, manually test it and visually verify everything. If all is good, we swing traffic to the cold server with the new code on it. We leave this running for a period of time to verify that everything is going okay, that errors aren't being logged, that customers aren't contacting us to say that the system isn't working. If a deployment does fail we can swing traffic back to the cold server with the old code on it. Otherwise, once we're sure the deployment is good the final step depends on the architecture. VPS: deploy the latest code to the cold server instance and then adjust the load balancer to split all traffic between them again. Cloud: shut down the cold virtual server, which can be kept around for a while just in case something catastrophic happens much later and it needs to be booted back up again, but that shut down server is now basically just a file sitting on a disk somewhere and it wouldn't be costing us anything. When it's time to roll out the *next* production deployment, that old server image can be deleted at the same time the new virtual server is spun up for the new deployment (or, it could be reused ... it does save some time if the setup required to go from a newly provisioned linux install to a fully deployed production server is extensive and takes a lot of time. On the other hand, the main benefit for rebuilding the entire server from a blank slate every time is that, if you had to stand up a new server fast, maybe even in a different environment, you have some assurances that everything is going to work, provided you're using the same or a similar distribution of linux and that you're not depending on any proprietary features coming from the service provider ... in theory you could setup a new server on any cloud or VPS provider, or a dedicated server, or even an old computer sitting in your basement theoretically and get the system back up and live very quickly).
* Developers working on the system on their computer should have a virtual machine image that they can boot up and install the system on using the same scripts that are used in production, mimicking the real system as closely as possible for testing purposes. This allows you to work on the system whether you use a mac, a windows PC or a linux OS and to keep your personal computer from being polluted with files from the system install, preventing weird compatibility issues between Mac, Windows and Linux from getting in the way. Also, in cases where a really difficult issue is stumping a developer, where the code all seems to run fine on someone else's machine, they can shut down the VM and send the whole image file to another developer, who can then boot it up and aid in troubleshooting it, because it is highly inlikely that the issue will not show up for that other person when working from the same virtual machine image.

## 1. Bitcoin

* [Bitcoin for Developers](https://bitcoin.org/en/bitcoin-for-developers): Free - This is the full technical docs for the low level functions of Bitcoin. It's not programming language specific, it deals rather with how to create and use the files and links that bitcoin is based on. You can develop against this but you have to perform every step in the process yourself, which is quite complex, developing against a third party API makes a lot more sense unless you for some reason need this level of control (i.e. you want to run your own bitcoin banking institution). This does however provide everything you could want to know about the inner workings of the whole system, which is useful for understanding what is going on behind the scenes, especially if end up troubleshooting difficult issues or you need to do something that you can't find an API to support. It has all technical specs on transactions, contracts, wallets, payments and even mining.
* [Blockchain API](https://blockchain.info/api): Free - Supports: Node.js, Python, Java, C#, Ruby, PHP - provides the following services: payment processing (accepting a bitcoin payment), wallet service (create wallets, send/recieve between wallets), blocks and transactions (retrieve info about a block or a transaction), market data (exchange rates and statistics).
* [Coinbase API](https://developers.coinbase.com/): Transaction Fee, Bitcoin Litecoin and Etherium - Supports: Node.js, Python, Java, Ruby and PHP - The Coinbase API starts off free, they have a 1% transaction fee to transfer coin to a bank account, but this only occurs once you have converted over $1,000,000 of coins. If you convert $1,000,000+ every month you become eligible for volume discount pricing. There are additional benefits to using this API that can help to save or protect money: to protect yourself from market volatility you can enable instant exchange, coins are immediately converted into local currency and transfered into your bank account once per day. For customers paying from Coinbase wallets, they allow micro transactions of 1 satoshi (0.00000001 BTC) vs the normal Bitcoin minimum of 0.001 BTC and they also waive mining fees for Coinbase wallets. In addition to the base functionality (wallets, send/recieve money and rates/info) they also provide notifications when payments are recieved and security for storing coins.

## 2. Litecoin

* Coinbase API: see above.
* [Litecore Node](https://github.com/litecoin-project/litecore-node): Free - This is a Litecoin server that runs in Node.js.  It has an extension providing additinal REST/Websocket APIs the [Insight API](https://github.com/litecoin-project/insight-lite-api) 
